// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LOGINPROTOCOL_LOGINPROTOCOL_H_
#define FLATBUFFERS_GENERATED_LOGINPROTOCOL_LOGINPROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace LoginProtocol {

struct Player;
struct PlayerBuilder;

struct C2S_KeepAlive;
struct C2S_KeepAliveBuilder;

struct S2C_KeepAlive;
struct S2C_KeepAliveBuilder;

struct C2S_LoginRequest;
struct C2S_LoginRequestBuilder;

struct S2C_LoginResponse;
struct S2C_LoginResponseBuilder;

struct C2S_SignUpRequest;
struct C2S_SignUpRequestBuilder;

struct S2C_SignUpResponse;
struct S2C_SignUpResponseBuilder;

struct C2S_PlayerListRequest;
struct C2S_PlayerListRequestBuilder;

struct S2C_PlayerListResponse;
struct S2C_PlayerListResponseBuilder;

struct S2C_PlayerInOutLobby;
struct S2C_PlayerInOutLobbyBuilder;

struct C2S_GameReadyRequest;
struct C2S_GameReadyRequestBuilder;

struct S2C_PlayerChangeState;
struct S2C_PlayerChangeStateBuilder;

struct S2C_CountdownStartGame;
struct S2C_CountdownStartGameBuilder;

struct S2C_StartGame;
struct S2C_StartGameBuilder;

struct C2S_MatchmakingRequest;
struct C2S_MatchmakingRequestBuilder;

struct S2C_MatchmakingResponse;
struct S2C_MatchmakingResponseBuilder;

struct MessageEnvelope;
struct MessageEnvelopeBuilder;

enum class C2S_Message : uint16_t {
  C2S_KeepAlive = 0,
  C2S_LoginRequest = 1,
  C2S_SignUpRequest = 2,
  C2S_PlayerListRequest = 3,
  C2S_GameReadyRequest = 4,
  C2S_MatchmakingRequest = 5,
  MIN = C2S_KeepAlive,
  MAX = C2S_MatchmakingRequest
};

inline const C2S_Message (&EnumValuesC2S_Message())[6] {
  static const C2S_Message values[] = {
    C2S_Message::C2S_KeepAlive,
    C2S_Message::C2S_LoginRequest,
    C2S_Message::C2S_SignUpRequest,
    C2S_Message::C2S_PlayerListRequest,
    C2S_Message::C2S_GameReadyRequest,
    C2S_Message::C2S_MatchmakingRequest
  };
  return values;
}

inline const char * const *EnumNamesC2S_Message() {
  static const char * const names[7] = {
    "C2S_KeepAlive",
    "C2S_LoginRequest",
    "C2S_SignUpRequest",
    "C2S_PlayerListRequest",
    "C2S_GameReadyRequest",
    "C2S_MatchmakingRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameC2S_Message(C2S_Message e) {
  if (::flatbuffers::IsOutRange(e, C2S_Message::C2S_KeepAlive, C2S_Message::C2S_MatchmakingRequest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesC2S_Message()[index];
}

enum class S2C_Message : uint16_t {
  S2C_KeepAlive = 0,
  S2C_LoginResponse = 1,
  S2C_SignUpResponse = 2,
  S2C_PlayerListResponse = 3,
  S2C_PlayerInOutLobby = 4,
  S2C_PlayerChangeState = 5,
  S2C_CountdownStartGame = 6,
  S2C_StartGame = 7,
  S2C_MatchmakingResponse = 8,
  MIN = S2C_KeepAlive,
  MAX = S2C_MatchmakingResponse
};

inline const S2C_Message (&EnumValuesS2C_Message())[9] {
  static const S2C_Message values[] = {
    S2C_Message::S2C_KeepAlive,
    S2C_Message::S2C_LoginResponse,
    S2C_Message::S2C_SignUpResponse,
    S2C_Message::S2C_PlayerListResponse,
    S2C_Message::S2C_PlayerInOutLobby,
    S2C_Message::S2C_PlayerChangeState,
    S2C_Message::S2C_CountdownStartGame,
    S2C_Message::S2C_StartGame,
    S2C_Message::S2C_MatchmakingResponse
  };
  return values;
}

inline const char * const *EnumNamesS2C_Message() {
  static const char * const names[10] = {
    "S2C_KeepAlive",
    "S2C_LoginResponse",
    "S2C_SignUpResponse",
    "S2C_PlayerListResponse",
    "S2C_PlayerInOutLobby",
    "S2C_PlayerChangeState",
    "S2C_CountdownStartGame",
    "S2C_StartGame",
    "S2C_MatchmakingResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameS2C_Message(S2C_Message e) {
  if (::flatbuffers::IsOutRange(e, S2C_Message::S2C_KeepAlive, S2C_Message::S2C_MatchmakingResponse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesS2C_Message()[index];
}

enum class ErrorCode : uint8_t {
  Success = 0,
  Login_Fail_UserNotFound = 1,
  Login_Fail_InvalidPassword = 2,
  SignUp_Fail_UsernameExists = 3,
  SignUp_Fail_NicknameExists = 4,
  Auth_Fail_InvalidToken = 5,
  InvalidRequest = 6,
  ServerError = 7,
  MIN = Success,
  MAX = ServerError
};

inline const ErrorCode (&EnumValuesErrorCode())[8] {
  static const ErrorCode values[] = {
    ErrorCode::Success,
    ErrorCode::Login_Fail_UserNotFound,
    ErrorCode::Login_Fail_InvalidPassword,
    ErrorCode::SignUp_Fail_UsernameExists,
    ErrorCode::SignUp_Fail_NicknameExists,
    ErrorCode::Auth_Fail_InvalidToken,
    ErrorCode::InvalidRequest,
    ErrorCode::ServerError
  };
  return values;
}

inline const char * const *EnumNamesErrorCode() {
  static const char * const names[9] = {
    "Success",
    "Login_Fail_UserNotFound",
    "Login_Fail_InvalidPassword",
    "SignUp_Fail_UsernameExists",
    "SignUp_Fail_NicknameExists",
    "Auth_Fail_InvalidToken",
    "InvalidRequest",
    "ServerError",
    nullptr
  };
  return names;
}

inline const char *EnumNameErrorCode(ErrorCode e) {
  if (::flatbuffers::IsOutRange(e, ErrorCode::Success, ErrorCode::ServerError)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesErrorCode()[index];
}

enum class PlayerState : uint8_t {
  Lobby = 0,
  Ready = 1,
  InGame = 2,
  MIN = Lobby,
  MAX = InGame
};

inline const PlayerState (&EnumValuesPlayerState())[3] {
  static const PlayerState values[] = {
    PlayerState::Lobby,
    PlayerState::Ready,
    PlayerState::InGame
  };
  return values;
}

inline const char * const *EnumNamesPlayerState() {
  static const char * const names[4] = {
    "Lobby",
    "Ready",
    "InGame",
    nullptr
  };
  return names;
}

inline const char *EnumNamePlayerState(PlayerState e) {
  if (::flatbuffers::IsOutRange(e, PlayerState::Lobby, PlayerState::InGame)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPlayerState()[index];
}

enum class Payload : uint8_t {
  NONE = 0,
  C2S_KeepAlive = 1,
  C2S_LoginRequest = 2,
  C2S_SignUpRequest = 3,
  C2S_PlayerListRequest = 4,
  C2S_GameReadyRequest = 5,
  C2S_MatchmakingRequest = 6,
  S2C_KeepAlive = 7,
  S2C_LoginResponse = 8,
  S2C_SignUpResponse = 9,
  S2C_PlayerListResponse = 10,
  S2C_PlayerChangeState = 11,
  S2C_PlayerInOutLobby = 12,
  S2C_CountdownStartGame = 13,
  S2C_StartGame = 14,
  S2C_MatchmakingResponse = 15,
  MIN = NONE,
  MAX = S2C_MatchmakingResponse
};

inline const Payload (&EnumValuesPayload())[16] {
  static const Payload values[] = {
    Payload::NONE,
    Payload::C2S_KeepAlive,
    Payload::C2S_LoginRequest,
    Payload::C2S_SignUpRequest,
    Payload::C2S_PlayerListRequest,
    Payload::C2S_GameReadyRequest,
    Payload::C2S_MatchmakingRequest,
    Payload::S2C_KeepAlive,
    Payload::S2C_LoginResponse,
    Payload::S2C_SignUpResponse,
    Payload::S2C_PlayerListResponse,
    Payload::S2C_PlayerChangeState,
    Payload::S2C_PlayerInOutLobby,
    Payload::S2C_CountdownStartGame,
    Payload::S2C_StartGame,
    Payload::S2C_MatchmakingResponse
  };
  return values;
}

inline const char * const *EnumNamesPayload() {
  static const char * const names[17] = {
    "NONE",
    "C2S_KeepAlive",
    "C2S_LoginRequest",
    "C2S_SignUpRequest",
    "C2S_PlayerListRequest",
    "C2S_GameReadyRequest",
    "C2S_MatchmakingRequest",
    "S2C_KeepAlive",
    "S2C_LoginResponse",
    "S2C_SignUpResponse",
    "S2C_PlayerListResponse",
    "S2C_PlayerChangeState",
    "S2C_PlayerInOutLobby",
    "S2C_CountdownStartGame",
    "S2C_StartGame",
    "S2C_MatchmakingResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNamePayload(Payload e) {
  if (::flatbuffers::IsOutRange(e, Payload::NONE, Payload::S2C_MatchmakingResponse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPayload()[index];
}

template<typename T> struct PayloadTraits {
  static const Payload enum_value = Payload::NONE;
};

template<> struct PayloadTraits<LoginProtocol::C2S_KeepAlive> {
  static const Payload enum_value = Payload::C2S_KeepAlive;
};

template<> struct PayloadTraits<LoginProtocol::C2S_LoginRequest> {
  static const Payload enum_value = Payload::C2S_LoginRequest;
};

template<> struct PayloadTraits<LoginProtocol::C2S_SignUpRequest> {
  static const Payload enum_value = Payload::C2S_SignUpRequest;
};

template<> struct PayloadTraits<LoginProtocol::C2S_PlayerListRequest> {
  static const Payload enum_value = Payload::C2S_PlayerListRequest;
};

template<> struct PayloadTraits<LoginProtocol::C2S_GameReadyRequest> {
  static const Payload enum_value = Payload::C2S_GameReadyRequest;
};

template<> struct PayloadTraits<LoginProtocol::C2S_MatchmakingRequest> {
  static const Payload enum_value = Payload::C2S_MatchmakingRequest;
};

template<> struct PayloadTraits<LoginProtocol::S2C_KeepAlive> {
  static const Payload enum_value = Payload::S2C_KeepAlive;
};

template<> struct PayloadTraits<LoginProtocol::S2C_LoginResponse> {
  static const Payload enum_value = Payload::S2C_LoginResponse;
};

template<> struct PayloadTraits<LoginProtocol::S2C_SignUpResponse> {
  static const Payload enum_value = Payload::S2C_SignUpResponse;
};

template<> struct PayloadTraits<LoginProtocol::S2C_PlayerListResponse> {
  static const Payload enum_value = Payload::S2C_PlayerListResponse;
};

template<> struct PayloadTraits<LoginProtocol::S2C_PlayerChangeState> {
  static const Payload enum_value = Payload::S2C_PlayerChangeState;
};

template<> struct PayloadTraits<LoginProtocol::S2C_PlayerInOutLobby> {
  static const Payload enum_value = Payload::S2C_PlayerInOutLobby;
};

template<> struct PayloadTraits<LoginProtocol::S2C_CountdownStartGame> {
  static const Payload enum_value = Payload::S2C_CountdownStartGame;
};

template<> struct PayloadTraits<LoginProtocol::S2C_StartGame> {
  static const Payload enum_value = Payload::S2C_StartGame;
};

template<> struct PayloadTraits<LoginProtocol::S2C_MatchmakingResponse> {
  static const Payload enum_value = Payload::S2C_MatchmakingResponse;
};

bool VerifyPayload(::flatbuffers::Verifier &verifier, const void *obj, Payload type);
bool VerifyPayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Payload> *types);

struct Player FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USER_ID = 4,
    VT_NICKNAME = 6,
    VT_STATE = 8
  };
  const ::flatbuffers::String *user_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USER_ID);
  }
  const ::flatbuffers::String *nickname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NICKNAME);
  }
  LoginProtocol::PlayerState state() const {
    return static_cast<LoginProtocol::PlayerState>(GetField<uint8_t>(VT_STATE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USER_ID) &&
           verifier.VerifyString(user_id()) &&
           VerifyOffset(verifier, VT_NICKNAME) &&
           verifier.VerifyString(nickname()) &&
           VerifyField<uint8_t>(verifier, VT_STATE, 1) &&
           verifier.EndTable();
  }
};

struct PlayerBuilder {
  typedef Player Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_user_id(::flatbuffers::Offset<::flatbuffers::String> user_id) {
    fbb_.AddOffset(Player::VT_USER_ID, user_id);
  }
  void add_nickname(::flatbuffers::Offset<::flatbuffers::String> nickname) {
    fbb_.AddOffset(Player::VT_NICKNAME, nickname);
  }
  void add_state(LoginProtocol::PlayerState state) {
    fbb_.AddElement<uint8_t>(Player::VT_STATE, static_cast<uint8_t>(state), 0);
  }
  explicit PlayerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Player> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Player>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Player> CreatePlayer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> user_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> nickname = 0,
    LoginProtocol::PlayerState state = LoginProtocol::PlayerState::Lobby) {
  PlayerBuilder builder_(_fbb);
  builder_.add_nickname(nickname);
  builder_.add_user_id(user_id);
  builder_.add_state(state);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Player> CreatePlayerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *user_id = nullptr,
    const char *nickname = nullptr,
    LoginProtocol::PlayerState state = LoginProtocol::PlayerState::Lobby) {
  auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
  auto nickname__ = nickname ? _fbb.CreateString(nickname) : 0;
  return LoginProtocol::CreatePlayer(
      _fbb,
      user_id__,
      nickname__,
      state);
}

struct C2S_KeepAlive FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C2S_KeepAliveBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct C2S_KeepAliveBuilder {
  typedef C2S_KeepAlive Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit C2S_KeepAliveBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C2S_KeepAlive> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C2S_KeepAlive>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<C2S_KeepAlive> CreateC2S_KeepAlive(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  C2S_KeepAliveBuilder builder_(_fbb);
  return builder_.Finish();
}

struct S2C_KeepAlive FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef S2C_KeepAliveBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct S2C_KeepAliveBuilder {
  typedef S2C_KeepAlive Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit S2C_KeepAliveBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<S2C_KeepAlive> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<S2C_KeepAlive>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<S2C_KeepAlive> CreateS2C_KeepAlive(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  S2C_KeepAliveBuilder builder_(_fbb);
  return builder_.Finish();
}

struct C2S_LoginRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C2S_LoginRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USERID = 4,
    VT_PASSWORD = 6
  };
  const ::flatbuffers::String *userid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USERID);
  }
  const ::flatbuffers::String *password() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_USERID) &&
           verifier.VerifyString(userid()) &&
           VerifyOffsetRequired(verifier, VT_PASSWORD) &&
           verifier.VerifyString(password()) &&
           verifier.EndTable();
  }
};

struct C2S_LoginRequestBuilder {
  typedef C2S_LoginRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_userid(::flatbuffers::Offset<::flatbuffers::String> userid) {
    fbb_.AddOffset(C2S_LoginRequest::VT_USERID, userid);
  }
  void add_password(::flatbuffers::Offset<::flatbuffers::String> password) {
    fbb_.AddOffset(C2S_LoginRequest::VT_PASSWORD, password);
  }
  explicit C2S_LoginRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C2S_LoginRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C2S_LoginRequest>(end);
    fbb_.Required(o, C2S_LoginRequest::VT_USERID);
    fbb_.Required(o, C2S_LoginRequest::VT_PASSWORD);
    return o;
  }
};

inline ::flatbuffers::Offset<C2S_LoginRequest> CreateC2S_LoginRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> userid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> password = 0) {
  C2S_LoginRequestBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_userid(userid);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<C2S_LoginRequest> CreateC2S_LoginRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *userid = nullptr,
    const char *password = nullptr) {
  auto userid__ = userid ? _fbb.CreateString(userid) : 0;
  auto password__ = password ? _fbb.CreateString(password) : 0;
  return LoginProtocol::CreateC2S_LoginRequest(
      _fbb,
      userid__,
      password__);
}

struct S2C_LoginResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef S2C_LoginResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4,
    VT_SESSION_TOKEN = 6,
    VT_NICKNAME = 8
  };
  LoginProtocol::ErrorCode error_code() const {
    return static_cast<LoginProtocol::ErrorCode>(GetField<uint8_t>(VT_ERROR_CODE, 0));
  }
  const ::flatbuffers::String *session_token() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SESSION_TOKEN);
  }
  const ::flatbuffers::String *nickname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NICKNAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ERROR_CODE, 1) &&
           VerifyOffset(verifier, VT_SESSION_TOKEN) &&
           verifier.VerifyString(session_token()) &&
           VerifyOffset(verifier, VT_NICKNAME) &&
           verifier.VerifyString(nickname()) &&
           verifier.EndTable();
  }
};

struct S2C_LoginResponseBuilder {
  typedef S2C_LoginResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_error_code(LoginProtocol::ErrorCode error_code) {
    fbb_.AddElement<uint8_t>(S2C_LoginResponse::VT_ERROR_CODE, static_cast<uint8_t>(error_code), 0);
  }
  void add_session_token(::flatbuffers::Offset<::flatbuffers::String> session_token) {
    fbb_.AddOffset(S2C_LoginResponse::VT_SESSION_TOKEN, session_token);
  }
  void add_nickname(::flatbuffers::Offset<::flatbuffers::String> nickname) {
    fbb_.AddOffset(S2C_LoginResponse::VT_NICKNAME, nickname);
  }
  explicit S2C_LoginResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<S2C_LoginResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<S2C_LoginResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<S2C_LoginResponse> CreateS2C_LoginResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    LoginProtocol::ErrorCode error_code = LoginProtocol::ErrorCode::Success,
    ::flatbuffers::Offset<::flatbuffers::String> session_token = 0,
    ::flatbuffers::Offset<::flatbuffers::String> nickname = 0) {
  S2C_LoginResponseBuilder builder_(_fbb);
  builder_.add_nickname(nickname);
  builder_.add_session_token(session_token);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<S2C_LoginResponse> CreateS2C_LoginResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    LoginProtocol::ErrorCode error_code = LoginProtocol::ErrorCode::Success,
    const char *session_token = nullptr,
    const char *nickname = nullptr) {
  auto session_token__ = session_token ? _fbb.CreateString(session_token) : 0;
  auto nickname__ = nickname ? _fbb.CreateString(nickname) : 0;
  return LoginProtocol::CreateS2C_LoginResponse(
      _fbb,
      error_code,
      session_token__,
      nickname__);
}

struct C2S_SignUpRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C2S_SignUpRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USERID = 4,
    VT_PASSWORD = 6,
    VT_NICKNAME = 8
  };
  const ::flatbuffers::String *userid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USERID);
  }
  const ::flatbuffers::String *password() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PASSWORD);
  }
  const ::flatbuffers::String *nickname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NICKNAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_USERID) &&
           verifier.VerifyString(userid()) &&
           VerifyOffsetRequired(verifier, VT_PASSWORD) &&
           verifier.VerifyString(password()) &&
           VerifyOffsetRequired(verifier, VT_NICKNAME) &&
           verifier.VerifyString(nickname()) &&
           verifier.EndTable();
  }
};

struct C2S_SignUpRequestBuilder {
  typedef C2S_SignUpRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_userid(::flatbuffers::Offset<::flatbuffers::String> userid) {
    fbb_.AddOffset(C2S_SignUpRequest::VT_USERID, userid);
  }
  void add_password(::flatbuffers::Offset<::flatbuffers::String> password) {
    fbb_.AddOffset(C2S_SignUpRequest::VT_PASSWORD, password);
  }
  void add_nickname(::flatbuffers::Offset<::flatbuffers::String> nickname) {
    fbb_.AddOffset(C2S_SignUpRequest::VT_NICKNAME, nickname);
  }
  explicit C2S_SignUpRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C2S_SignUpRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C2S_SignUpRequest>(end);
    fbb_.Required(o, C2S_SignUpRequest::VT_USERID);
    fbb_.Required(o, C2S_SignUpRequest::VT_PASSWORD);
    fbb_.Required(o, C2S_SignUpRequest::VT_NICKNAME);
    return o;
  }
};

inline ::flatbuffers::Offset<C2S_SignUpRequest> CreateC2S_SignUpRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> userid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> password = 0,
    ::flatbuffers::Offset<::flatbuffers::String> nickname = 0) {
  C2S_SignUpRequestBuilder builder_(_fbb);
  builder_.add_nickname(nickname);
  builder_.add_password(password);
  builder_.add_userid(userid);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<C2S_SignUpRequest> CreateC2S_SignUpRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *userid = nullptr,
    const char *password = nullptr,
    const char *nickname = nullptr) {
  auto userid__ = userid ? _fbb.CreateString(userid) : 0;
  auto password__ = password ? _fbb.CreateString(password) : 0;
  auto nickname__ = nickname ? _fbb.CreateString(nickname) : 0;
  return LoginProtocol::CreateC2S_SignUpRequest(
      _fbb,
      userid__,
      password__,
      nickname__);
}

struct S2C_SignUpResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef S2C_SignUpResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4
  };
  LoginProtocol::ErrorCode error_code() const {
    return static_cast<LoginProtocol::ErrorCode>(GetField<uint8_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ERROR_CODE, 1) &&
           verifier.EndTable();
  }
};

struct S2C_SignUpResponseBuilder {
  typedef S2C_SignUpResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_error_code(LoginProtocol::ErrorCode error_code) {
    fbb_.AddElement<uint8_t>(S2C_SignUpResponse::VT_ERROR_CODE, static_cast<uint8_t>(error_code), 0);
  }
  explicit S2C_SignUpResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<S2C_SignUpResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<S2C_SignUpResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<S2C_SignUpResponse> CreateS2C_SignUpResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    LoginProtocol::ErrorCode error_code = LoginProtocol::ErrorCode::Success) {
  S2C_SignUpResponseBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

struct C2S_PlayerListRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C2S_PlayerListRequestBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct C2S_PlayerListRequestBuilder {
  typedef C2S_PlayerListRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit C2S_PlayerListRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C2S_PlayerListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C2S_PlayerListRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<C2S_PlayerListRequest> CreateC2S_PlayerListRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  C2S_PlayerListRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct S2C_PlayerListResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef S2C_PlayerListResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYERS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<LoginProtocol::Player>> *players() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<LoginProtocol::Player>> *>(VT_PLAYERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLAYERS) &&
           verifier.VerifyVector(players()) &&
           verifier.VerifyVectorOfTables(players()) &&
           verifier.EndTable();
  }
};

struct S2C_PlayerListResponseBuilder {
  typedef S2C_PlayerListResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_players(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LoginProtocol::Player>>> players) {
    fbb_.AddOffset(S2C_PlayerListResponse::VT_PLAYERS, players);
  }
  explicit S2C_PlayerListResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<S2C_PlayerListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<S2C_PlayerListResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<S2C_PlayerListResponse> CreateS2C_PlayerListResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LoginProtocol::Player>>> players = 0) {
  S2C_PlayerListResponseBuilder builder_(_fbb);
  builder_.add_players(players);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<S2C_PlayerListResponse> CreateS2C_PlayerListResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<LoginProtocol::Player>> *players = nullptr) {
  auto players__ = players ? _fbb.CreateVector<::flatbuffers::Offset<LoginProtocol::Player>>(*players) : 0;
  return LoginProtocol::CreateS2C_PlayerListResponse(
      _fbb,
      players__);
}

struct S2C_PlayerInOutLobby FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef S2C_PlayerInOutLobbyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER = 4,
    VT_IS_JOIN = 6
  };
  const LoginProtocol::Player *player() const {
    return GetPointer<const LoginProtocol::Player *>(VT_PLAYER);
  }
  bool is_join() const {
    return GetField<uint8_t>(VT_IS_JOIN, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLAYER) &&
           verifier.VerifyTable(player()) &&
           VerifyField<uint8_t>(verifier, VT_IS_JOIN, 1) &&
           verifier.EndTable();
  }
};

struct S2C_PlayerInOutLobbyBuilder {
  typedef S2C_PlayerInOutLobby Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_player(::flatbuffers::Offset<LoginProtocol::Player> player) {
    fbb_.AddOffset(S2C_PlayerInOutLobby::VT_PLAYER, player);
  }
  void add_is_join(bool is_join) {
    fbb_.AddElement<uint8_t>(S2C_PlayerInOutLobby::VT_IS_JOIN, static_cast<uint8_t>(is_join), 0);
  }
  explicit S2C_PlayerInOutLobbyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<S2C_PlayerInOutLobby> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<S2C_PlayerInOutLobby>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<S2C_PlayerInOutLobby> CreateS2C_PlayerInOutLobby(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<LoginProtocol::Player> player = 0,
    bool is_join = false) {
  S2C_PlayerInOutLobbyBuilder builder_(_fbb);
  builder_.add_player(player);
  builder_.add_is_join(is_join);
  return builder_.Finish();
}

struct C2S_GameReadyRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C2S_GameReadyRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSION_TOKEN = 4,
    VT_IS_READY = 6
  };
  const ::flatbuffers::String *session_token() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SESSION_TOKEN);
  }
  bool is_ready() const {
    return GetField<uint8_t>(VT_IS_READY, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SESSION_TOKEN) &&
           verifier.VerifyString(session_token()) &&
           VerifyField<uint8_t>(verifier, VT_IS_READY, 1) &&
           verifier.EndTable();
  }
};

struct C2S_GameReadyRequestBuilder {
  typedef C2S_GameReadyRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_session_token(::flatbuffers::Offset<::flatbuffers::String> session_token) {
    fbb_.AddOffset(C2S_GameReadyRequest::VT_SESSION_TOKEN, session_token);
  }
  void add_is_ready(bool is_ready) {
    fbb_.AddElement<uint8_t>(C2S_GameReadyRequest::VT_IS_READY, static_cast<uint8_t>(is_ready), 0);
  }
  explicit C2S_GameReadyRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C2S_GameReadyRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C2S_GameReadyRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<C2S_GameReadyRequest> CreateC2S_GameReadyRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> session_token = 0,
    bool is_ready = false) {
  C2S_GameReadyRequestBuilder builder_(_fbb);
  builder_.add_session_token(session_token);
  builder_.add_is_ready(is_ready);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<C2S_GameReadyRequest> CreateC2S_GameReadyRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *session_token = nullptr,
    bool is_ready = false) {
  auto session_token__ = session_token ? _fbb.CreateString(session_token) : 0;
  return LoginProtocol::CreateC2S_GameReadyRequest(
      _fbb,
      session_token__,
      is_ready);
}

struct S2C_PlayerChangeState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef S2C_PlayerChangeStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USER_ID = 4,
    VT_STATE = 6
  };
  const ::flatbuffers::String *user_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USER_ID);
  }
  LoginProtocol::PlayerState state() const {
    return static_cast<LoginProtocol::PlayerState>(GetField<uint8_t>(VT_STATE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USER_ID) &&
           verifier.VerifyString(user_id()) &&
           VerifyField<uint8_t>(verifier, VT_STATE, 1) &&
           verifier.EndTable();
  }
};

struct S2C_PlayerChangeStateBuilder {
  typedef S2C_PlayerChangeState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_user_id(::flatbuffers::Offset<::flatbuffers::String> user_id) {
    fbb_.AddOffset(S2C_PlayerChangeState::VT_USER_ID, user_id);
  }
  void add_state(LoginProtocol::PlayerState state) {
    fbb_.AddElement<uint8_t>(S2C_PlayerChangeState::VT_STATE, static_cast<uint8_t>(state), 0);
  }
  explicit S2C_PlayerChangeStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<S2C_PlayerChangeState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<S2C_PlayerChangeState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<S2C_PlayerChangeState> CreateS2C_PlayerChangeState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> user_id = 0,
    LoginProtocol::PlayerState state = LoginProtocol::PlayerState::Lobby) {
  S2C_PlayerChangeStateBuilder builder_(_fbb);
  builder_.add_user_id(user_id);
  builder_.add_state(state);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<S2C_PlayerChangeState> CreateS2C_PlayerChangeStateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *user_id = nullptr,
    LoginProtocol::PlayerState state = LoginProtocol::PlayerState::Lobby) {
  auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
  return LoginProtocol::CreateS2C_PlayerChangeState(
      _fbb,
      user_id__,
      state);
}

struct S2C_CountdownStartGame FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef S2C_CountdownStartGameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_START = 4,
    VT_COUNTDOWN = 6
  };
  bool is_start() const {
    return GetField<uint8_t>(VT_IS_START, 0) != 0;
  }
  uint32_t countdown() const {
    return GetField<uint32_t>(VT_COUNTDOWN, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_START, 1) &&
           VerifyField<uint32_t>(verifier, VT_COUNTDOWN, 4) &&
           verifier.EndTable();
  }
};

struct S2C_CountdownStartGameBuilder {
  typedef S2C_CountdownStartGame Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_is_start(bool is_start) {
    fbb_.AddElement<uint8_t>(S2C_CountdownStartGame::VT_IS_START, static_cast<uint8_t>(is_start), 0);
  }
  void add_countdown(uint32_t countdown) {
    fbb_.AddElement<uint32_t>(S2C_CountdownStartGame::VT_COUNTDOWN, countdown, 0);
  }
  explicit S2C_CountdownStartGameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<S2C_CountdownStartGame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<S2C_CountdownStartGame>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<S2C_CountdownStartGame> CreateS2C_CountdownStartGame(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool is_start = false,
    uint32_t countdown = 0) {
  S2C_CountdownStartGameBuilder builder_(_fbb);
  builder_.add_countdown(countdown);
  builder_.add_is_start(is_start);
  return builder_.Finish();
}

struct S2C_StartGame FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef S2C_StartGameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEDI_IP_ADDRESS = 4,
    VT_DEDI_PORT = 6
  };
  const ::flatbuffers::String *dedi_ip_address() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEDI_IP_ADDRESS);
  }
  uint16_t dedi_port() const {
    return GetField<uint16_t>(VT_DEDI_PORT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEDI_IP_ADDRESS) &&
           verifier.VerifyString(dedi_ip_address()) &&
           VerifyField<uint16_t>(verifier, VT_DEDI_PORT, 2) &&
           verifier.EndTable();
  }
};

struct S2C_StartGameBuilder {
  typedef S2C_StartGame Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dedi_ip_address(::flatbuffers::Offset<::flatbuffers::String> dedi_ip_address) {
    fbb_.AddOffset(S2C_StartGame::VT_DEDI_IP_ADDRESS, dedi_ip_address);
  }
  void add_dedi_port(uint16_t dedi_port) {
    fbb_.AddElement<uint16_t>(S2C_StartGame::VT_DEDI_PORT, dedi_port, 0);
  }
  explicit S2C_StartGameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<S2C_StartGame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<S2C_StartGame>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<S2C_StartGame> CreateS2C_StartGame(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> dedi_ip_address = 0,
    uint16_t dedi_port = 0) {
  S2C_StartGameBuilder builder_(_fbb);
  builder_.add_dedi_ip_address(dedi_ip_address);
  builder_.add_dedi_port(dedi_port);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<S2C_StartGame> CreateS2C_StartGameDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *dedi_ip_address = nullptr,
    uint16_t dedi_port = 0) {
  auto dedi_ip_address__ = dedi_ip_address ? _fbb.CreateString(dedi_ip_address) : 0;
  return LoginProtocol::CreateS2C_StartGame(
      _fbb,
      dedi_ip_address__,
      dedi_port);
}

struct C2S_MatchmakingRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C2S_MatchmakingRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSION_TOKEN = 4
  };
  const ::flatbuffers::String *session_token() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SESSION_TOKEN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SESSION_TOKEN) &&
           verifier.VerifyString(session_token()) &&
           verifier.EndTable();
  }
};

struct C2S_MatchmakingRequestBuilder {
  typedef C2S_MatchmakingRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_session_token(::flatbuffers::Offset<::flatbuffers::String> session_token) {
    fbb_.AddOffset(C2S_MatchmakingRequest::VT_SESSION_TOKEN, session_token);
  }
  explicit C2S_MatchmakingRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C2S_MatchmakingRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C2S_MatchmakingRequest>(end);
    fbb_.Required(o, C2S_MatchmakingRequest::VT_SESSION_TOKEN);
    return o;
  }
};

inline ::flatbuffers::Offset<C2S_MatchmakingRequest> CreateC2S_MatchmakingRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> session_token = 0) {
  C2S_MatchmakingRequestBuilder builder_(_fbb);
  builder_.add_session_token(session_token);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<C2S_MatchmakingRequest> CreateC2S_MatchmakingRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *session_token = nullptr) {
  auto session_token__ = session_token ? _fbb.CreateString(session_token) : 0;
  return LoginProtocol::CreateC2S_MatchmakingRequest(
      _fbb,
      session_token__);
}

struct S2C_MatchmakingResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef S2C_MatchmakingResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4,
    VT_IP_ADDRESS = 6,
    VT_PORT = 8
  };
  LoginProtocol::ErrorCode error_code() const {
    return static_cast<LoginProtocol::ErrorCode>(GetField<uint8_t>(VT_ERROR_CODE, 0));
  }
  const ::flatbuffers::String *ip_address() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IP_ADDRESS);
  }
  uint16_t port() const {
    return GetField<uint16_t>(VT_PORT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ERROR_CODE, 1) &&
           VerifyOffset(verifier, VT_IP_ADDRESS) &&
           verifier.VerifyString(ip_address()) &&
           VerifyField<uint16_t>(verifier, VT_PORT, 2) &&
           verifier.EndTable();
  }
};

struct S2C_MatchmakingResponseBuilder {
  typedef S2C_MatchmakingResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_error_code(LoginProtocol::ErrorCode error_code) {
    fbb_.AddElement<uint8_t>(S2C_MatchmakingResponse::VT_ERROR_CODE, static_cast<uint8_t>(error_code), 0);
  }
  void add_ip_address(::flatbuffers::Offset<::flatbuffers::String> ip_address) {
    fbb_.AddOffset(S2C_MatchmakingResponse::VT_IP_ADDRESS, ip_address);
  }
  void add_port(uint16_t port) {
    fbb_.AddElement<uint16_t>(S2C_MatchmakingResponse::VT_PORT, port, 0);
  }
  explicit S2C_MatchmakingResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<S2C_MatchmakingResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<S2C_MatchmakingResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<S2C_MatchmakingResponse> CreateS2C_MatchmakingResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    LoginProtocol::ErrorCode error_code = LoginProtocol::ErrorCode::Success,
    ::flatbuffers::Offset<::flatbuffers::String> ip_address = 0,
    uint16_t port = 0) {
  S2C_MatchmakingResponseBuilder builder_(_fbb);
  builder_.add_ip_address(ip_address);
  builder_.add_port(port);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<S2C_MatchmakingResponse> CreateS2C_MatchmakingResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    LoginProtocol::ErrorCode error_code = LoginProtocol::ErrorCode::Success,
    const char *ip_address = nullptr,
    uint16_t port = 0) {
  auto ip_address__ = ip_address ? _fbb.CreateString(ip_address) : 0;
  return LoginProtocol::CreateS2C_MatchmakingResponse(
      _fbb,
      error_code,
      ip_address__,
      port);
}

struct MessageEnvelope FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MessageEnvelopeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_BODY_TYPE = 6,
    VT_BODY = 8
  };
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  LoginProtocol::Payload body_type() const {
    return static_cast<LoginProtocol::Payload>(GetField<uint8_t>(VT_BODY_TYPE, 0));
  }
  const void *body() const {
    return GetPointer<const void *>(VT_BODY);
  }
  template<typename T> const T *body_as() const;
  const LoginProtocol::C2S_KeepAlive *body_as_C2S_KeepAlive() const {
    return body_type() == LoginProtocol::Payload::C2S_KeepAlive ? static_cast<const LoginProtocol::C2S_KeepAlive *>(body()) : nullptr;
  }
  const LoginProtocol::C2S_LoginRequest *body_as_C2S_LoginRequest() const {
    return body_type() == LoginProtocol::Payload::C2S_LoginRequest ? static_cast<const LoginProtocol::C2S_LoginRequest *>(body()) : nullptr;
  }
  const LoginProtocol::C2S_SignUpRequest *body_as_C2S_SignUpRequest() const {
    return body_type() == LoginProtocol::Payload::C2S_SignUpRequest ? static_cast<const LoginProtocol::C2S_SignUpRequest *>(body()) : nullptr;
  }
  const LoginProtocol::C2S_PlayerListRequest *body_as_C2S_PlayerListRequest() const {
    return body_type() == LoginProtocol::Payload::C2S_PlayerListRequest ? static_cast<const LoginProtocol::C2S_PlayerListRequest *>(body()) : nullptr;
  }
  const LoginProtocol::C2S_GameReadyRequest *body_as_C2S_GameReadyRequest() const {
    return body_type() == LoginProtocol::Payload::C2S_GameReadyRequest ? static_cast<const LoginProtocol::C2S_GameReadyRequest *>(body()) : nullptr;
  }
  const LoginProtocol::C2S_MatchmakingRequest *body_as_C2S_MatchmakingRequest() const {
    return body_type() == LoginProtocol::Payload::C2S_MatchmakingRequest ? static_cast<const LoginProtocol::C2S_MatchmakingRequest *>(body()) : nullptr;
  }
  const LoginProtocol::S2C_KeepAlive *body_as_S2C_KeepAlive() const {
    return body_type() == LoginProtocol::Payload::S2C_KeepAlive ? static_cast<const LoginProtocol::S2C_KeepAlive *>(body()) : nullptr;
  }
  const LoginProtocol::S2C_LoginResponse *body_as_S2C_LoginResponse() const {
    return body_type() == LoginProtocol::Payload::S2C_LoginResponse ? static_cast<const LoginProtocol::S2C_LoginResponse *>(body()) : nullptr;
  }
  const LoginProtocol::S2C_SignUpResponse *body_as_S2C_SignUpResponse() const {
    return body_type() == LoginProtocol::Payload::S2C_SignUpResponse ? static_cast<const LoginProtocol::S2C_SignUpResponse *>(body()) : nullptr;
  }
  const LoginProtocol::S2C_PlayerListResponse *body_as_S2C_PlayerListResponse() const {
    return body_type() == LoginProtocol::Payload::S2C_PlayerListResponse ? static_cast<const LoginProtocol::S2C_PlayerListResponse *>(body()) : nullptr;
  }
  const LoginProtocol::S2C_PlayerChangeState *body_as_S2C_PlayerChangeState() const {
    return body_type() == LoginProtocol::Payload::S2C_PlayerChangeState ? static_cast<const LoginProtocol::S2C_PlayerChangeState *>(body()) : nullptr;
  }
  const LoginProtocol::S2C_PlayerInOutLobby *body_as_S2C_PlayerInOutLobby() const {
    return body_type() == LoginProtocol::Payload::S2C_PlayerInOutLobby ? static_cast<const LoginProtocol::S2C_PlayerInOutLobby *>(body()) : nullptr;
  }
  const LoginProtocol::S2C_CountdownStartGame *body_as_S2C_CountdownStartGame() const {
    return body_type() == LoginProtocol::Payload::S2C_CountdownStartGame ? static_cast<const LoginProtocol::S2C_CountdownStartGame *>(body()) : nullptr;
  }
  const LoginProtocol::S2C_StartGame *body_as_S2C_StartGame() const {
    return body_type() == LoginProtocol::Payload::S2C_StartGame ? static_cast<const LoginProtocol::S2C_StartGame *>(body()) : nullptr;
  }
  const LoginProtocol::S2C_MatchmakingResponse *body_as_S2C_MatchmakingResponse() const {
    return body_type() == LoginProtocol::Payload::S2C_MatchmakingResponse ? static_cast<const LoginProtocol::S2C_MatchmakingResponse *>(body()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           VerifyField<uint8_t>(verifier, VT_BODY_TYPE, 1) &&
           VerifyOffset(verifier, VT_BODY) &&
           VerifyPayload(verifier, body(), body_type()) &&
           verifier.EndTable();
  }
};

template<> inline const LoginProtocol::C2S_KeepAlive *MessageEnvelope::body_as<LoginProtocol::C2S_KeepAlive>() const {
  return body_as_C2S_KeepAlive();
}

template<> inline const LoginProtocol::C2S_LoginRequest *MessageEnvelope::body_as<LoginProtocol::C2S_LoginRequest>() const {
  return body_as_C2S_LoginRequest();
}

template<> inline const LoginProtocol::C2S_SignUpRequest *MessageEnvelope::body_as<LoginProtocol::C2S_SignUpRequest>() const {
  return body_as_C2S_SignUpRequest();
}

template<> inline const LoginProtocol::C2S_PlayerListRequest *MessageEnvelope::body_as<LoginProtocol::C2S_PlayerListRequest>() const {
  return body_as_C2S_PlayerListRequest();
}

template<> inline const LoginProtocol::C2S_GameReadyRequest *MessageEnvelope::body_as<LoginProtocol::C2S_GameReadyRequest>() const {
  return body_as_C2S_GameReadyRequest();
}

template<> inline const LoginProtocol::C2S_MatchmakingRequest *MessageEnvelope::body_as<LoginProtocol::C2S_MatchmakingRequest>() const {
  return body_as_C2S_MatchmakingRequest();
}

template<> inline const LoginProtocol::S2C_KeepAlive *MessageEnvelope::body_as<LoginProtocol::S2C_KeepAlive>() const {
  return body_as_S2C_KeepAlive();
}

template<> inline const LoginProtocol::S2C_LoginResponse *MessageEnvelope::body_as<LoginProtocol::S2C_LoginResponse>() const {
  return body_as_S2C_LoginResponse();
}

template<> inline const LoginProtocol::S2C_SignUpResponse *MessageEnvelope::body_as<LoginProtocol::S2C_SignUpResponse>() const {
  return body_as_S2C_SignUpResponse();
}

template<> inline const LoginProtocol::S2C_PlayerListResponse *MessageEnvelope::body_as<LoginProtocol::S2C_PlayerListResponse>() const {
  return body_as_S2C_PlayerListResponse();
}

template<> inline const LoginProtocol::S2C_PlayerChangeState *MessageEnvelope::body_as<LoginProtocol::S2C_PlayerChangeState>() const {
  return body_as_S2C_PlayerChangeState();
}

template<> inline const LoginProtocol::S2C_PlayerInOutLobby *MessageEnvelope::body_as<LoginProtocol::S2C_PlayerInOutLobby>() const {
  return body_as_S2C_PlayerInOutLobby();
}

template<> inline const LoginProtocol::S2C_CountdownStartGame *MessageEnvelope::body_as<LoginProtocol::S2C_CountdownStartGame>() const {
  return body_as_S2C_CountdownStartGame();
}

template<> inline const LoginProtocol::S2C_StartGame *MessageEnvelope::body_as<LoginProtocol::S2C_StartGame>() const {
  return body_as_S2C_StartGame();
}

template<> inline const LoginProtocol::S2C_MatchmakingResponse *MessageEnvelope::body_as<LoginProtocol::S2C_MatchmakingResponse>() const {
  return body_as_S2C_MatchmakingResponse();
}

struct MessageEnvelopeBuilder {
  typedef MessageEnvelope Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(MessageEnvelope::VT_TIMESTAMP, timestamp, 0);
  }
  void add_body_type(LoginProtocol::Payload body_type) {
    fbb_.AddElement<uint8_t>(MessageEnvelope::VT_BODY_TYPE, static_cast<uint8_t>(body_type), 0);
  }
  void add_body(::flatbuffers::Offset<void> body) {
    fbb_.AddOffset(MessageEnvelope::VT_BODY, body);
  }
  explicit MessageEnvelopeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MessageEnvelope> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MessageEnvelope>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MessageEnvelope> CreateMessageEnvelope(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t timestamp = 0,
    LoginProtocol::Payload body_type = LoginProtocol::Payload::NONE,
    ::flatbuffers::Offset<void> body = 0) {
  MessageEnvelopeBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_body(body);
  builder_.add_body_type(body_type);
  return builder_.Finish();
}

inline bool VerifyPayload(::flatbuffers::Verifier &verifier, const void *obj, Payload type) {
  switch (type) {
    case Payload::NONE: {
      return true;
    }
    case Payload::C2S_KeepAlive: {
      auto ptr = reinterpret_cast<const LoginProtocol::C2S_KeepAlive *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::C2S_LoginRequest: {
      auto ptr = reinterpret_cast<const LoginProtocol::C2S_LoginRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::C2S_SignUpRequest: {
      auto ptr = reinterpret_cast<const LoginProtocol::C2S_SignUpRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::C2S_PlayerListRequest: {
      auto ptr = reinterpret_cast<const LoginProtocol::C2S_PlayerListRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::C2S_GameReadyRequest: {
      auto ptr = reinterpret_cast<const LoginProtocol::C2S_GameReadyRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::C2S_MatchmakingRequest: {
      auto ptr = reinterpret_cast<const LoginProtocol::C2S_MatchmakingRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::S2C_KeepAlive: {
      auto ptr = reinterpret_cast<const LoginProtocol::S2C_KeepAlive *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::S2C_LoginResponse: {
      auto ptr = reinterpret_cast<const LoginProtocol::S2C_LoginResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::S2C_SignUpResponse: {
      auto ptr = reinterpret_cast<const LoginProtocol::S2C_SignUpResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::S2C_PlayerListResponse: {
      auto ptr = reinterpret_cast<const LoginProtocol::S2C_PlayerListResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::S2C_PlayerChangeState: {
      auto ptr = reinterpret_cast<const LoginProtocol::S2C_PlayerChangeState *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::S2C_PlayerInOutLobby: {
      auto ptr = reinterpret_cast<const LoginProtocol::S2C_PlayerInOutLobby *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::S2C_CountdownStartGame: {
      auto ptr = reinterpret_cast<const LoginProtocol::S2C_CountdownStartGame *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::S2C_StartGame: {
      auto ptr = reinterpret_cast<const LoginProtocol::S2C_StartGame *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload::S2C_MatchmakingResponse: {
      auto ptr = reinterpret_cast<const LoginProtocol::S2C_MatchmakingResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Payload> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPayload(
        verifier,  values->Get(i), types->GetEnum<Payload>(i))) {
      return false;
    }
  }
  return true;
}

inline const LoginProtocol::MessageEnvelope *GetMessageEnvelope(const void *buf) {
  return ::flatbuffers::GetRoot<LoginProtocol::MessageEnvelope>(buf);
}

inline const LoginProtocol::MessageEnvelope *GetSizePrefixedMessageEnvelope(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<LoginProtocol::MessageEnvelope>(buf);
}

inline bool VerifyMessageEnvelopeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<LoginProtocol::MessageEnvelope>(nullptr);
}

inline bool VerifySizePrefixedMessageEnvelopeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<LoginProtocol::MessageEnvelope>(nullptr);
}

inline void FinishMessageEnvelopeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<LoginProtocol::MessageEnvelope> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageEnvelopeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<LoginProtocol::MessageEnvelope> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace LoginProtocol

#endif  // FLATBUFFERS_GENERATED_LOGINPROTOCOL_LOGINPROTOCOL_H_
