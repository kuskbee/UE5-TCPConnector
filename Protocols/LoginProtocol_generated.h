// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LOGINPROTOCOL_LOGINPROTOCOL_H_
#define FLATBUFFERS_GENERATED_LOGINPROTOCOL_LOGINPROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace LoginProtocol {

struct C2S_KeepAlive;
struct C2S_KeepAliveBuilder;

struct S2C_KeepAlive;
struct S2C_KeepAliveBuilder;

struct C2S_LoginRequest;
struct C2S_LoginRequestBuilder;

struct S2C_LoginResponse;
struct S2C_LoginResponseBuilder;

struct C2S_SignUpRequest;
struct C2S_SignUpRequestBuilder;

struct S2C_SignUpResponse;
struct S2C_SignUpResponseBuilder;

struct C2S_MatchmakingRequest;
struct C2S_MatchmakingRequestBuilder;

struct S2C_MatchmakingResponse;
struct S2C_MatchmakingResponseBuilder;

struct MessageEnvelope;
struct MessageEnvelopeBuilder;

enum C2S_Message : uint16_t {
  C2S_Message_C2S_KeepAlive = 0,
  C2S_Message_C2S_LoginRequest = 1,
  C2S_Message_C2S_SignUpRequest = 2,
  C2S_Message_C2S_MatchmakingRequest = 3,
  C2S_Message_MIN = C2S_Message_C2S_KeepAlive,
  C2S_Message_MAX = C2S_Message_C2S_MatchmakingRequest
};

inline const C2S_Message (&EnumValuesC2S_Message())[4] {
  static const C2S_Message values[] = {
    C2S_Message_C2S_KeepAlive,
    C2S_Message_C2S_LoginRequest,
    C2S_Message_C2S_SignUpRequest,
    C2S_Message_C2S_MatchmakingRequest
  };
  return values;
}

inline const char * const *EnumNamesC2S_Message() {
  static const char * const names[5] = {
    "C2S_KeepAlive",
    "C2S_LoginRequest",
    "C2S_SignUpRequest",
    "C2S_MatchmakingRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameC2S_Message(C2S_Message e) {
  if (::flatbuffers::IsOutRange(e, C2S_Message_C2S_KeepAlive, C2S_Message_C2S_MatchmakingRequest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesC2S_Message()[index];
}

enum S2C_Message : uint16_t {
  S2C_Message_S2C_KeepAlive = 0,
  S2C_Message_S2C_LoginResponse = 1,
  S2C_Message_S2C_SignUpResponse = 2,
  S2C_Message_S2C_MatchmakingResponse = 3,
  S2C_Message_MIN = S2C_Message_S2C_KeepAlive,
  S2C_Message_MAX = S2C_Message_S2C_MatchmakingResponse
};

inline const S2C_Message (&EnumValuesS2C_Message())[4] {
  static const S2C_Message values[] = {
    S2C_Message_S2C_KeepAlive,
    S2C_Message_S2C_LoginResponse,
    S2C_Message_S2C_SignUpResponse,
    S2C_Message_S2C_MatchmakingResponse
  };
  return values;
}

inline const char * const *EnumNamesS2C_Message() {
  static const char * const names[5] = {
    "S2C_KeepAlive",
    "S2C_LoginResponse",
    "S2C_SignUpResponse",
    "S2C_MatchmakingResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameS2C_Message(S2C_Message e) {
  if (::flatbuffers::IsOutRange(e, S2C_Message_S2C_KeepAlive, S2C_Message_S2C_MatchmakingResponse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesS2C_Message()[index];
}

enum ErrorCode : uint16_t {
  ErrorCode_Success = 0,
  ErrorCode_Login_Fail_UserNotFound = 1,
  ErrorCode_Login_Fail_InvalidPassword = 2,
  ErrorCode_SignUp_Fail_UsernameExists = 3,
  ErrorCode_SignUp_Fail_NicknameExists = 4,
  ErrorCode_Auth_Fail_InvalidToken = 5,
  ErrorCode_InvalidRequest = 6,
  ErrorCode_ServerError = 7,
  ErrorCode_MIN = ErrorCode_Success,
  ErrorCode_MAX = ErrorCode_ServerError
};

inline const ErrorCode (&EnumValuesErrorCode())[8] {
  static const ErrorCode values[] = {
    ErrorCode_Success,
    ErrorCode_Login_Fail_UserNotFound,
    ErrorCode_Login_Fail_InvalidPassword,
    ErrorCode_SignUp_Fail_UsernameExists,
    ErrorCode_SignUp_Fail_NicknameExists,
    ErrorCode_Auth_Fail_InvalidToken,
    ErrorCode_InvalidRequest,
    ErrorCode_ServerError
  };
  return values;
}

inline const char * const *EnumNamesErrorCode() {
  static const char * const names[9] = {
    "Success",
    "Login_Fail_UserNotFound",
    "Login_Fail_InvalidPassword",
    "SignUp_Fail_UsernameExists",
    "SignUp_Fail_NicknameExists",
    "Auth_Fail_InvalidToken",
    "InvalidRequest",
    "ServerError",
    nullptr
  };
  return names;
}

inline const char *EnumNameErrorCode(ErrorCode e) {
  if (::flatbuffers::IsOutRange(e, ErrorCode_Success, ErrorCode_ServerError)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesErrorCode()[index];
}

enum Payload : uint8_t {
  Payload_NONE = 0,
  Payload_C2S_KeepAlive = 1,
  Payload_C2S_LoginRequest = 2,
  Payload_C2S_SignUpRequest = 3,
  Payload_C2S_MatchmakingRequest = 4,
  Payload_S2C_KeepAlive = 5,
  Payload_S2C_LoginResponse = 6,
  Payload_S2C_SignUpResponse = 7,
  Payload_S2C_MatchmakingResponse = 8,
  Payload_MIN = Payload_NONE,
  Payload_MAX = Payload_S2C_MatchmakingResponse
};

inline const Payload (&EnumValuesPayload())[9] {
  static const Payload values[] = {
    Payload_NONE,
    Payload_C2S_KeepAlive,
    Payload_C2S_LoginRequest,
    Payload_C2S_SignUpRequest,
    Payload_C2S_MatchmakingRequest,
    Payload_S2C_KeepAlive,
    Payload_S2C_LoginResponse,
    Payload_S2C_SignUpResponse,
    Payload_S2C_MatchmakingResponse
  };
  return values;
}

inline const char * const *EnumNamesPayload() {
  static const char * const names[10] = {
    "NONE",
    "C2S_KeepAlive",
    "C2S_LoginRequest",
    "C2S_SignUpRequest",
    "C2S_MatchmakingRequest",
    "S2C_KeepAlive",
    "S2C_LoginResponse",
    "S2C_SignUpResponse",
    "S2C_MatchmakingResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNamePayload(Payload e) {
  if (::flatbuffers::IsOutRange(e, Payload_NONE, Payload_S2C_MatchmakingResponse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPayload()[index];
}

template<typename T> struct PayloadTraits {
  static const Payload enum_value = Payload_NONE;
};

template<> struct PayloadTraits<LoginProtocol::C2S_KeepAlive> {
  static const Payload enum_value = Payload_C2S_KeepAlive;
};

template<> struct PayloadTraits<LoginProtocol::C2S_LoginRequest> {
  static const Payload enum_value = Payload_C2S_LoginRequest;
};

template<> struct PayloadTraits<LoginProtocol::C2S_SignUpRequest> {
  static const Payload enum_value = Payload_C2S_SignUpRequest;
};

template<> struct PayloadTraits<LoginProtocol::C2S_MatchmakingRequest> {
  static const Payload enum_value = Payload_C2S_MatchmakingRequest;
};

template<> struct PayloadTraits<LoginProtocol::S2C_KeepAlive> {
  static const Payload enum_value = Payload_S2C_KeepAlive;
};

template<> struct PayloadTraits<LoginProtocol::S2C_LoginResponse> {
  static const Payload enum_value = Payload_S2C_LoginResponse;
};

template<> struct PayloadTraits<LoginProtocol::S2C_SignUpResponse> {
  static const Payload enum_value = Payload_S2C_SignUpResponse;
};

template<> struct PayloadTraits<LoginProtocol::S2C_MatchmakingResponse> {
  static const Payload enum_value = Payload_S2C_MatchmakingResponse;
};

bool VerifyPayload(::flatbuffers::Verifier &verifier, const void *obj, Payload type);
bool VerifyPayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct C2S_KeepAlive FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C2S_KeepAliveBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct C2S_KeepAliveBuilder {
  typedef C2S_KeepAlive Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit C2S_KeepAliveBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C2S_KeepAlive> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C2S_KeepAlive>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<C2S_KeepAlive> CreateC2S_KeepAlive(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  C2S_KeepAliveBuilder builder_(_fbb);
  return builder_.Finish();
}

struct S2C_KeepAlive FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef S2C_KeepAliveBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct S2C_KeepAliveBuilder {
  typedef S2C_KeepAlive Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit S2C_KeepAliveBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<S2C_KeepAlive> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<S2C_KeepAlive>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<S2C_KeepAlive> CreateS2C_KeepAlive(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  S2C_KeepAliveBuilder builder_(_fbb);
  return builder_.Finish();
}

struct C2S_LoginRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C2S_LoginRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USERID = 4,
    VT_PASSWORD = 6
  };
  const ::flatbuffers::String *userid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USERID);
  }
  const ::flatbuffers::String *password() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_USERID) &&
           verifier.VerifyString(userid()) &&
           VerifyOffsetRequired(verifier, VT_PASSWORD) &&
           verifier.VerifyString(password()) &&
           verifier.EndTable();
  }
};

struct C2S_LoginRequestBuilder {
  typedef C2S_LoginRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_userid(::flatbuffers::Offset<::flatbuffers::String> userid) {
    fbb_.AddOffset(C2S_LoginRequest::VT_USERID, userid);
  }
  void add_password(::flatbuffers::Offset<::flatbuffers::String> password) {
    fbb_.AddOffset(C2S_LoginRequest::VT_PASSWORD, password);
  }
  explicit C2S_LoginRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C2S_LoginRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C2S_LoginRequest>(end);
    fbb_.Required(o, C2S_LoginRequest::VT_USERID);
    fbb_.Required(o, C2S_LoginRequest::VT_PASSWORD);
    return o;
  }
};

inline ::flatbuffers::Offset<C2S_LoginRequest> CreateC2S_LoginRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> userid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> password = 0) {
  C2S_LoginRequestBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_userid(userid);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<C2S_LoginRequest> CreateC2S_LoginRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *userid = nullptr,
    const char *password = nullptr) {
  auto userid__ = userid ? _fbb.CreateString(userid) : 0;
  auto password__ = password ? _fbb.CreateString(password) : 0;
  return LoginProtocol::CreateC2S_LoginRequest(
      _fbb,
      userid__,
      password__);
}

struct S2C_LoginResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef S2C_LoginResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4,
    VT_SESSION_TOKEN = 6,
    VT_NICKNAME = 8
  };
  LoginProtocol::ErrorCode error_code() const {
    return static_cast<LoginProtocol::ErrorCode>(GetField<uint16_t>(VT_ERROR_CODE, 0));
  }
  const ::flatbuffers::String *session_token() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SESSION_TOKEN);
  }
  const ::flatbuffers::String *nickname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NICKNAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_CODE, 2) &&
           VerifyOffset(verifier, VT_SESSION_TOKEN) &&
           verifier.VerifyString(session_token()) &&
           VerifyOffset(verifier, VT_NICKNAME) &&
           verifier.VerifyString(nickname()) &&
           verifier.EndTable();
  }
};

struct S2C_LoginResponseBuilder {
  typedef S2C_LoginResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_error_code(LoginProtocol::ErrorCode error_code) {
    fbb_.AddElement<uint16_t>(S2C_LoginResponse::VT_ERROR_CODE, static_cast<uint16_t>(error_code), 0);
  }
  void add_session_token(::flatbuffers::Offset<::flatbuffers::String> session_token) {
    fbb_.AddOffset(S2C_LoginResponse::VT_SESSION_TOKEN, session_token);
  }
  void add_nickname(::flatbuffers::Offset<::flatbuffers::String> nickname) {
    fbb_.AddOffset(S2C_LoginResponse::VT_NICKNAME, nickname);
  }
  explicit S2C_LoginResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<S2C_LoginResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<S2C_LoginResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<S2C_LoginResponse> CreateS2C_LoginResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    LoginProtocol::ErrorCode error_code = LoginProtocol::ErrorCode_Success,
    ::flatbuffers::Offset<::flatbuffers::String> session_token = 0,
    ::flatbuffers::Offset<::flatbuffers::String> nickname = 0) {
  S2C_LoginResponseBuilder builder_(_fbb);
  builder_.add_nickname(nickname);
  builder_.add_session_token(session_token);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<S2C_LoginResponse> CreateS2C_LoginResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    LoginProtocol::ErrorCode error_code = LoginProtocol::ErrorCode_Success,
    const char *session_token = nullptr,
    const char *nickname = nullptr) {
  auto session_token__ = session_token ? _fbb.CreateString(session_token) : 0;
  auto nickname__ = nickname ? _fbb.CreateString(nickname) : 0;
  return LoginProtocol::CreateS2C_LoginResponse(
      _fbb,
      error_code,
      session_token__,
      nickname__);
}

struct C2S_SignUpRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C2S_SignUpRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USERID = 4,
    VT_PASSWORD = 6,
    VT_NICKNAME = 8
  };
  const ::flatbuffers::String *userid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USERID);
  }
  const ::flatbuffers::String *password() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PASSWORD);
  }
  const ::flatbuffers::String *nickname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NICKNAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_USERID) &&
           verifier.VerifyString(userid()) &&
           VerifyOffsetRequired(verifier, VT_PASSWORD) &&
           verifier.VerifyString(password()) &&
           VerifyOffsetRequired(verifier, VT_NICKNAME) &&
           verifier.VerifyString(nickname()) &&
           verifier.EndTable();
  }
};

struct C2S_SignUpRequestBuilder {
  typedef C2S_SignUpRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_userid(::flatbuffers::Offset<::flatbuffers::String> userid) {
    fbb_.AddOffset(C2S_SignUpRequest::VT_USERID, userid);
  }
  void add_password(::flatbuffers::Offset<::flatbuffers::String> password) {
    fbb_.AddOffset(C2S_SignUpRequest::VT_PASSWORD, password);
  }
  void add_nickname(::flatbuffers::Offset<::flatbuffers::String> nickname) {
    fbb_.AddOffset(C2S_SignUpRequest::VT_NICKNAME, nickname);
  }
  explicit C2S_SignUpRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C2S_SignUpRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C2S_SignUpRequest>(end);
    fbb_.Required(o, C2S_SignUpRequest::VT_USERID);
    fbb_.Required(o, C2S_SignUpRequest::VT_PASSWORD);
    fbb_.Required(o, C2S_SignUpRequest::VT_NICKNAME);
    return o;
  }
};

inline ::flatbuffers::Offset<C2S_SignUpRequest> CreateC2S_SignUpRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> userid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> password = 0,
    ::flatbuffers::Offset<::flatbuffers::String> nickname = 0) {
  C2S_SignUpRequestBuilder builder_(_fbb);
  builder_.add_nickname(nickname);
  builder_.add_password(password);
  builder_.add_userid(userid);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<C2S_SignUpRequest> CreateC2S_SignUpRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *userid = nullptr,
    const char *password = nullptr,
    const char *nickname = nullptr) {
  auto userid__ = userid ? _fbb.CreateString(userid) : 0;
  auto password__ = password ? _fbb.CreateString(password) : 0;
  auto nickname__ = nickname ? _fbb.CreateString(nickname) : 0;
  return LoginProtocol::CreateC2S_SignUpRequest(
      _fbb,
      userid__,
      password__,
      nickname__);
}

struct S2C_SignUpResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef S2C_SignUpResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4
  };
  LoginProtocol::ErrorCode error_code() const {
    return static_cast<LoginProtocol::ErrorCode>(GetField<uint16_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_CODE, 2) &&
           verifier.EndTable();
  }
};

struct S2C_SignUpResponseBuilder {
  typedef S2C_SignUpResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_error_code(LoginProtocol::ErrorCode error_code) {
    fbb_.AddElement<uint16_t>(S2C_SignUpResponse::VT_ERROR_CODE, static_cast<uint16_t>(error_code), 0);
  }
  explicit S2C_SignUpResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<S2C_SignUpResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<S2C_SignUpResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<S2C_SignUpResponse> CreateS2C_SignUpResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    LoginProtocol::ErrorCode error_code = LoginProtocol::ErrorCode_Success) {
  S2C_SignUpResponseBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

struct C2S_MatchmakingRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C2S_MatchmakingRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSION_TOKEN = 4
  };
  const ::flatbuffers::String *session_token() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SESSION_TOKEN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SESSION_TOKEN) &&
           verifier.VerifyString(session_token()) &&
           verifier.EndTable();
  }
};

struct C2S_MatchmakingRequestBuilder {
  typedef C2S_MatchmakingRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_session_token(::flatbuffers::Offset<::flatbuffers::String> session_token) {
    fbb_.AddOffset(C2S_MatchmakingRequest::VT_SESSION_TOKEN, session_token);
  }
  explicit C2S_MatchmakingRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C2S_MatchmakingRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C2S_MatchmakingRequest>(end);
    fbb_.Required(o, C2S_MatchmakingRequest::VT_SESSION_TOKEN);
    return o;
  }
};

inline ::flatbuffers::Offset<C2S_MatchmakingRequest> CreateC2S_MatchmakingRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> session_token = 0) {
  C2S_MatchmakingRequestBuilder builder_(_fbb);
  builder_.add_session_token(session_token);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<C2S_MatchmakingRequest> CreateC2S_MatchmakingRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *session_token = nullptr) {
  auto session_token__ = session_token ? _fbb.CreateString(session_token) : 0;
  return LoginProtocol::CreateC2S_MatchmakingRequest(
      _fbb,
      session_token__);
}

struct S2C_MatchmakingResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef S2C_MatchmakingResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4,
    VT_IP_ADDRESS = 6,
    VT_PORT = 8
  };
  LoginProtocol::ErrorCode error_code() const {
    return static_cast<LoginProtocol::ErrorCode>(GetField<uint16_t>(VT_ERROR_CODE, 0));
  }
  const ::flatbuffers::String *ip_address() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IP_ADDRESS);
  }
  uint16_t port() const {
    return GetField<uint16_t>(VT_PORT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_CODE, 2) &&
           VerifyOffset(verifier, VT_IP_ADDRESS) &&
           verifier.VerifyString(ip_address()) &&
           VerifyField<uint16_t>(verifier, VT_PORT, 2) &&
           verifier.EndTable();
  }
};

struct S2C_MatchmakingResponseBuilder {
  typedef S2C_MatchmakingResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_error_code(LoginProtocol::ErrorCode error_code) {
    fbb_.AddElement<uint16_t>(S2C_MatchmakingResponse::VT_ERROR_CODE, static_cast<uint16_t>(error_code), 0);
  }
  void add_ip_address(::flatbuffers::Offset<::flatbuffers::String> ip_address) {
    fbb_.AddOffset(S2C_MatchmakingResponse::VT_IP_ADDRESS, ip_address);
  }
  void add_port(uint16_t port) {
    fbb_.AddElement<uint16_t>(S2C_MatchmakingResponse::VT_PORT, port, 0);
  }
  explicit S2C_MatchmakingResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<S2C_MatchmakingResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<S2C_MatchmakingResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<S2C_MatchmakingResponse> CreateS2C_MatchmakingResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    LoginProtocol::ErrorCode error_code = LoginProtocol::ErrorCode_Success,
    ::flatbuffers::Offset<::flatbuffers::String> ip_address = 0,
    uint16_t port = 0) {
  S2C_MatchmakingResponseBuilder builder_(_fbb);
  builder_.add_ip_address(ip_address);
  builder_.add_port(port);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<S2C_MatchmakingResponse> CreateS2C_MatchmakingResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    LoginProtocol::ErrorCode error_code = LoginProtocol::ErrorCode_Success,
    const char *ip_address = nullptr,
    uint16_t port = 0) {
  auto ip_address__ = ip_address ? _fbb.CreateString(ip_address) : 0;
  return LoginProtocol::CreateS2C_MatchmakingResponse(
      _fbb,
      error_code,
      ip_address__,
      port);
}

struct MessageEnvelope FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MessageEnvelopeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_BODY_TYPE = 6,
    VT_BODY = 8
  };
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  LoginProtocol::Payload body_type() const {
    return static_cast<LoginProtocol::Payload>(GetField<uint8_t>(VT_BODY_TYPE, 0));
  }
  const void *body() const {
    return GetPointer<const void *>(VT_BODY);
  }
  template<typename T> const T *body_as() const;
  const LoginProtocol::C2S_KeepAlive *body_as_C2S_KeepAlive() const {
    return body_type() == LoginProtocol::Payload_C2S_KeepAlive ? static_cast<const LoginProtocol::C2S_KeepAlive *>(body()) : nullptr;
  }
  const LoginProtocol::C2S_LoginRequest *body_as_C2S_LoginRequest() const {
    return body_type() == LoginProtocol::Payload_C2S_LoginRequest ? static_cast<const LoginProtocol::C2S_LoginRequest *>(body()) : nullptr;
  }
  const LoginProtocol::C2S_SignUpRequest *body_as_C2S_SignUpRequest() const {
    return body_type() == LoginProtocol::Payload_C2S_SignUpRequest ? static_cast<const LoginProtocol::C2S_SignUpRequest *>(body()) : nullptr;
  }
  const LoginProtocol::C2S_MatchmakingRequest *body_as_C2S_MatchmakingRequest() const {
    return body_type() == LoginProtocol::Payload_C2S_MatchmakingRequest ? static_cast<const LoginProtocol::C2S_MatchmakingRequest *>(body()) : nullptr;
  }
  const LoginProtocol::S2C_KeepAlive *body_as_S2C_KeepAlive() const {
    return body_type() == LoginProtocol::Payload_S2C_KeepAlive ? static_cast<const LoginProtocol::S2C_KeepAlive *>(body()) : nullptr;
  }
  const LoginProtocol::S2C_LoginResponse *body_as_S2C_LoginResponse() const {
    return body_type() == LoginProtocol::Payload_S2C_LoginResponse ? static_cast<const LoginProtocol::S2C_LoginResponse *>(body()) : nullptr;
  }
  const LoginProtocol::S2C_SignUpResponse *body_as_S2C_SignUpResponse() const {
    return body_type() == LoginProtocol::Payload_S2C_SignUpResponse ? static_cast<const LoginProtocol::S2C_SignUpResponse *>(body()) : nullptr;
  }
  const LoginProtocol::S2C_MatchmakingResponse *body_as_S2C_MatchmakingResponse() const {
    return body_type() == LoginProtocol::Payload_S2C_MatchmakingResponse ? static_cast<const LoginProtocol::S2C_MatchmakingResponse *>(body()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           VerifyField<uint8_t>(verifier, VT_BODY_TYPE, 1) &&
           VerifyOffset(verifier, VT_BODY) &&
           VerifyPayload(verifier, body(), body_type()) &&
           verifier.EndTable();
  }
};

template<> inline const LoginProtocol::C2S_KeepAlive *MessageEnvelope::body_as<LoginProtocol::C2S_KeepAlive>() const {
  return body_as_C2S_KeepAlive();
}

template<> inline const LoginProtocol::C2S_LoginRequest *MessageEnvelope::body_as<LoginProtocol::C2S_LoginRequest>() const {
  return body_as_C2S_LoginRequest();
}

template<> inline const LoginProtocol::C2S_SignUpRequest *MessageEnvelope::body_as<LoginProtocol::C2S_SignUpRequest>() const {
  return body_as_C2S_SignUpRequest();
}

template<> inline const LoginProtocol::C2S_MatchmakingRequest *MessageEnvelope::body_as<LoginProtocol::C2S_MatchmakingRequest>() const {
  return body_as_C2S_MatchmakingRequest();
}

template<> inline const LoginProtocol::S2C_KeepAlive *MessageEnvelope::body_as<LoginProtocol::S2C_KeepAlive>() const {
  return body_as_S2C_KeepAlive();
}

template<> inline const LoginProtocol::S2C_LoginResponse *MessageEnvelope::body_as<LoginProtocol::S2C_LoginResponse>() const {
  return body_as_S2C_LoginResponse();
}

template<> inline const LoginProtocol::S2C_SignUpResponse *MessageEnvelope::body_as<LoginProtocol::S2C_SignUpResponse>() const {
  return body_as_S2C_SignUpResponse();
}

template<> inline const LoginProtocol::S2C_MatchmakingResponse *MessageEnvelope::body_as<LoginProtocol::S2C_MatchmakingResponse>() const {
  return body_as_S2C_MatchmakingResponse();
}

struct MessageEnvelopeBuilder {
  typedef MessageEnvelope Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(MessageEnvelope::VT_TIMESTAMP, timestamp, 0);
  }
  void add_body_type(LoginProtocol::Payload body_type) {
    fbb_.AddElement<uint8_t>(MessageEnvelope::VT_BODY_TYPE, static_cast<uint8_t>(body_type), 0);
  }
  void add_body(::flatbuffers::Offset<void> body) {
    fbb_.AddOffset(MessageEnvelope::VT_BODY, body);
  }
  explicit MessageEnvelopeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MessageEnvelope> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MessageEnvelope>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MessageEnvelope> CreateMessageEnvelope(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t timestamp = 0,
    LoginProtocol::Payload body_type = LoginProtocol::Payload_NONE,
    ::flatbuffers::Offset<void> body = 0) {
  MessageEnvelopeBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_body(body);
  builder_.add_body_type(body_type);
  return builder_.Finish();
}

inline bool VerifyPayload(::flatbuffers::Verifier &verifier, const void *obj, Payload type) {
  switch (type) {
    case Payload_NONE: {
      return true;
    }
    case Payload_C2S_KeepAlive: {
      auto ptr = reinterpret_cast<const LoginProtocol::C2S_KeepAlive *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_C2S_LoginRequest: {
      auto ptr = reinterpret_cast<const LoginProtocol::C2S_LoginRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_C2S_SignUpRequest: {
      auto ptr = reinterpret_cast<const LoginProtocol::C2S_SignUpRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_C2S_MatchmakingRequest: {
      auto ptr = reinterpret_cast<const LoginProtocol::C2S_MatchmakingRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_S2C_KeepAlive: {
      auto ptr = reinterpret_cast<const LoginProtocol::S2C_KeepAlive *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_S2C_LoginResponse: {
      auto ptr = reinterpret_cast<const LoginProtocol::S2C_LoginResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_S2C_SignUpResponse: {
      auto ptr = reinterpret_cast<const LoginProtocol::S2C_SignUpResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_S2C_MatchmakingResponse: {
      auto ptr = reinterpret_cast<const LoginProtocol::S2C_MatchmakingResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPayload(
        verifier,  values->Get(i), types->GetEnum<Payload>(i))) {
      return false;
    }
  }
  return true;
}

inline const LoginProtocol::MessageEnvelope *GetMessageEnvelope(const void *buf) {
  return ::flatbuffers::GetRoot<LoginProtocol::MessageEnvelope>(buf);
}

inline const LoginProtocol::MessageEnvelope *GetSizePrefixedMessageEnvelope(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<LoginProtocol::MessageEnvelope>(buf);
}

inline bool VerifyMessageEnvelopeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<LoginProtocol::MessageEnvelope>(nullptr);
}

inline bool VerifySizePrefixedMessageEnvelopeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<LoginProtocol::MessageEnvelope>(nullptr);
}

inline void FinishMessageEnvelopeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<LoginProtocol::MessageEnvelope> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageEnvelopeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<LoginProtocol::MessageEnvelope> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace LoginProtocol

#endif  // FLATBUFFERS_GENERATED_LOGINPROTOCOL_LOGINPROTOCOL_H_
